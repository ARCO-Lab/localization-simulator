{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Localization Simulator","text":""},{"location":"#description","title":"Description","text":"<p>A 2D/3D simulator for visualizing and performing experiments on trajectories in an environment to determine optimal sensor placement.</p> <p>More changes to be made for the simulator and documentation!</p>"},{"location":"#commands","title":"Commands","text":""},{"location":"#running-the-simulator","title":"Running the simulator","text":"<ul> <li><code>./run.sh</code> - Run the main simulation (2D). Make sure that the script is executable.</li> <li><code>python -m localization_simulator.core.main --3</code> - Run a 3D simulation (currently not fully implemented).</li> </ul>"},{"location":"#viewing-the-documentation","title":"Viewing the documentation","text":"<ul> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> </ul>"},{"location":"#installing-the-conda-environmentrequirements","title":"Installing the conda environment/requirements","text":"<ul> <li><code>conda env create -f environment.yml</code> - Create the localization conda environment. Please note that you'll need to add pip as a dependency in the <code>environment.yml</code> file. You can still proceed without doing so but risk unwanted behavior. Please change the prefix in the <code>environment.yml</code> to wherever you want to store the environment.</li> <li><code>pip install -r requirements.txt</code> - Install all the packages specified in the requirements file into your own environment.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>docs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\nlocalization_simulator/\n    core/ # Main simulator modules\n        component.py\n        error.py\n        main.py # The file to run the simulation\n        map.py\n        plot.py\n    site/ # Built documentation\n    test/ # Where testing modules will be added\n    utils/ # Utility modules\n        helper.py\n        nls.py\n        trajectory.py\nenvironment.yml\nmkdocs.yml    # The configuration file.\nrequirements.txt\nrun.sh\n</code></pre>"},{"location":"component/","title":"component","text":"<p>A module for creating components that can be used within the simulation map such as anchors, robots, or other potential entities for the simulation environment.</p> Todo <ul> <li>Fully implement and integrate robot component</li> <li>Rework the trajectory module in utils as a robot component so multiple paths can be registered and other behaviour can be modelled in addition to trajectory</li> <li>Add anchor cutoff</li> </ul>"},{"location":"component/#localization_simulator.core.component.Anchor","title":"<code>Anchor</code>","text":"<p>Component module to model anchor/sensor/beacon behaviour in a simulation environment.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Anchor name/id.</p> <code>location</code> <code>tuple[float, float, optional(float)]</code> <p>A tuple of length 2 (2D map) or 3 (3D map) to represent the location of the anchor.</p> <code>nDim</code> <code>int</code> <p>Anchor dimensionality (either 2 or 3).</p> <code>cutoff</code> <code>float</code> <p>Radius around the anchor, in which readings can only be made for objects within the cutoff.</p> <code>error</code> <code>tuple[int]</code> <p>Anchor error model.</p> <code>clr</code> <code>str</code> <p>Colour of anchor for visualization purposes.</p> Source code in <code>localization_simulator/core/component.py</code> <pre><code>class Anchor:\n\"\"\"Component module to model anchor/sensor/beacon behaviour in a simulation environment.\n\n    Attributes:\n        name (str): Anchor name/id.\n        location (tuple[float, float, optional(float)]): A tuple of length 2 (2D map) or 3 (3D map) to represent the location of the anchor.\n        nDim (int): Anchor dimensionality (either 2 or 3).\n        cutoff (float): Radius around the anchor, in which readings can only be made for objects within the cutoff.\n        error (tuple[int]): Anchor error model.\n        clr (str): Colour of anchor for visualization purposes.\n    \"\"\"\n    def __init__(self,name, location, cutoff, error, clr) -&gt; None:\n        self.name = name\n        self.location = location\n        self.nDim = len(location)\n        self.cutoff = cutoff\n        self.error = Error(error[0],error[1])\n        self.clr = clr\n\n    def getDist(self, pose):\n        return np.linalg.norm(pose-self.location)\n</code></pre>"},{"location":"component/#localization_simulator.core.component.Robot","title":"<code>Robot</code>","text":"<p>Component module to model robot behaviour in a simulation environment (currently not used)</p> <p>Attributes:</p> Name Type Description <code>curPose</code> <code>str</code> <p>Current pose of the robot.</p> <code>trajectory</code> <code>Trajectory</code> <p>A designated robot trajectory.</p> <code>nDim</code> <code>str</code> <p>Robot dimensionality (either 2 or 3).</p> Source code in <code>localization_simulator/core/component.py</code> <pre><code>class Robot:\n\"\"\"Component module to model robot behaviour in a simulation environment (currently not used)\n\n    Attributes:\n        curPose (str): Current pose of the robot.\n        trajectory (Trajectory): A designated robot trajectory.\n        nDim (str): Robot dimensionality (either 2 or 3).\n    \"\"\"\n    def __init__(self, trajectory) -&gt; None:\n        self.curPose = None\n        self.trajectory = trajectory\n\n        initialPose = trajectory[0]\n        if all(len(x) == len(initialPose) for x in trajectory):\n            self.nDim = len(initialPose)\n        else:\n            raise ValueError(\"Pose Dimensionality is not consistent\")\n</code></pre>"},{"location":"error/","title":"error","text":"<p>A module for creating error models that can be integrated into individual anchors/beacons/sensors/robots (currently not being used).</p> Todo <ul> <li>Research and finalize on error model for anchors</li> <li>Fully implement and add to anchors</li> <li>Add exception handling</li> <li>Update chen</li> </ul>"},{"location":"error/#localization_simulator.core.error.Bias","title":"<code>Bias</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enum class for bias models</p> Source code in <code>localization_simulator/core/error.py</code> <pre><code>class Bias(Enum):\n\"\"\"Enum class for bias models\n    \"\"\"\n    gonzalez = gonzalez\n    chen = chen\n</code></pre>"},{"location":"error/#localization_simulator.core.error.Error","title":"<code>Error</code>","text":"<p>Error module that can be used by components.</p> <p>Attributes:</p> Name Type Description <code>mean</code> <code>float</code> <p>The distribution mean</p> <code>std_dev</code> <code>float</code> <p>The distribution standard deviation</p> Source code in <code>localization_simulator/core/error.py</code> <pre><code>class Error:\n\"\"\"Error module that can be used by components.\n\n    Attributes:\n        mean (float): The distribution mean\n        std_dev (float): The distribution standard deviation\n    \"\"\"\n    def __init__(self, mean, std_dev) -&gt; None:\n\"\"\"Init Method\n\n        Args:\n            mean (float): The distance from the robot to the UWB sensor.\n            std_dev (float): The distance from the robot to the UWB sensor.\n        \"\"\"\n        self.mean = mean\n        self.std_dev = std_dev\n\n    def getPDF(self, dist, mean=None):\n        return stats.norm.pdf(dist, loc=self.mean if mean is None else mean, scale=self.std_dev)\n</code></pre>"},{"location":"error/#localization_simulator.core.error.Error.__init__","title":"<code>__init__(mean, std_dev)</code>","text":"<p>Init Method</p> <p>Parameters:</p> Name Type Description Default <code>mean</code> <code>float</code> <p>The distance from the robot to the UWB sensor.</p> required <code>std_dev</code> <code>float</code> <p>The distance from the robot to the UWB sensor.</p> required Source code in <code>localization_simulator/core/error.py</code> <pre><code>def __init__(self, mean, std_dev) -&gt; None:\n\"\"\"Init Method\n\n    Args:\n        mean (float): The distance from the robot to the UWB sensor.\n        std_dev (float): The distance from the robot to the UWB sensor.\n    \"\"\"\n    self.mean = mean\n    self.std_dev = std_dev\n</code></pre>"},{"location":"error/#localization_simulator.core.error.Variance","title":"<code>Variance</code>","text":"<p>             Bases: <code>Enum</code></p> <p>Enum class for known sensor variance</p> Source code in <code>localization_simulator/core/error.py</code> <pre><code>class Variance(Enum):\n\"\"\"Enum class for known sensor variance\n    \"\"\"\n    uwb_skylab_sku603 = 10\n    uwb_Zebra = 10/3\n</code></pre>"},{"location":"error/#localization_simulator.core.error.chen","title":"<code>chen(envType, distance, exp, lognormrand)</code>","text":"<p>UWB bias model (No Loss of sight on 100-1300 m) based on chen et al.</p> <p>Parameters:</p> Name Type Description Default <code>envType</code> <code>str</code> <p>The distance from the robot to the UWB sensor.</p> required <code>distance</code> <code>float</code> <p>The distance from the robot to the UWB sensor.</p> required <code>exp</code> <code>float</code> <p>An exponent used in the calculation (Update).</p> required <code>lognormrand</code> <code>float</code> <p>A value used in the calculation (update).</p> required <p>Returns:</p> Type Description <code>float</code> <p>The distance bias</p> <p>Raises:</p> Type Description <code>Exception</code> <p>For any error it encounters (Change)</p> Source code in <code>localization_simulator/core/error.py</code> <pre><code>def chen(envType,distance,exp,lognormrand):\n\"\"\"UWB bias model (No Loss of sight on 100-1300 m) based on chen et al.\n\n    Args:\n        envType (str): The distance from the robot to the UWB sensor.\n        distance (float): The distance from the robot to the UWB sensor.\n        exp (float): An exponent used in the calculation (Update).\n        lognormrand (float): A value used in the calculation (update).\n\n    Returns:\n        (float): The distance bias\n\n    Raises:\n        Exception: For any error it encounters (Change)\n    \"\"\"\n    types = {\n        \"bad_urban\": 1,\n        \"urban\": 0.4,\n        \"suburban\":0.3,\n        \"rural\":0.1\n    }\n\n    try:\n        T1 = types[envType]\n    except:\n        raise Exception\n\n    trms = T1*(distance/1000**exp)*lognormrand\n    t = 2\n    return ((1/trms)*np.exp(-(t/trms)))*1000\n</code></pre>"},{"location":"error/#localization_simulator.core.error.gonzalez","title":"<code>gonzalez(distance)</code>","text":"<p>UWB bias model (Loss of sight conducted on 1-10m experiments) based on Gonzalez et al.</p> <p>Parameters:</p> Name Type Description Default <code>distance</code> <code>float</code> <p>The distance from the robot to the UWB sensor.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The distance bias</p> <p>Raises:</p> Source code in <code>localization_simulator/core/error.py</code> <pre><code>def gonzalez(distance):\n\"\"\"UWB bias model (Loss of sight conducted on 1-10m experiments) based on Gonzalez et al.\n\n    Args:\n        distance (float): The distance from the robot to the UWB sensor.\n\n    Returns:\n        (float): The distance bias\n\n    Raises:\n\n    \"\"\"\n    return 0.1*(1.01-np.exp(-0.17*distance))\n</code></pre>"},{"location":"helper/","title":"helper","text":"<p>A helper module for useful functions </p> Todo <ul> <li>N/A</li> </ul>"},{"location":"helper/#localization_simulator.utils.helper.parseArgs","title":"<code>parseArgs()</code>","text":"<p>Parses arguments for simulator. Currently used to select a 2D or 3D simulation</p> <p>Returns:</p> Type Description <code>list[bool]</code> <p>The argument selections</p> Source code in <code>localization_simulator/utils/helper.py</code> <pre><code>def parseArgs():\n\"\"\"Parses arguments for simulator. Currently used to select a 2D or 3D simulation\n\n     Returns:\n         (list[bool]): The argument selections\n     \"\"\"\n     retArgs = []\n     parser = argparse.ArgumentParser(formatter_class=argparse.ArgumentDefaultsHelpFormatter)\n     parser.add_argument(\"--2\", \"-dim2\", default = False, required = False, action=\"store_true\", help=\"Flag to show 2D.\")\n     parser.add_argument(\"--3\", \"-dim3\", default = False, required = False, action=\"store_true\", help=\"Flag to show 3D.\")\n     args = parser.parse_args()\n     for arg in vars(args):\n          retArgs.append(getattr(args, arg))\n     return retArgs\n</code></pre>"},{"location":"main/","title":"main","text":"<p>The main script to run the simulator</p> Todo <ul> <li>Improve the process of creating routines</li> </ul>"},{"location":"main/#localization_simulator.core.main.sampleRoutine2d","title":"<code>sampleRoutine2d()</code>","text":"<p>A sample routine for a 2D simulation</p> Source code in <code>localization_simulator/core/main.py</code> <pre><code>def sampleRoutine2d():\n\"\"\"A sample routine for a 2D simulation\n    \"\"\"\n    anchorList2d = [Anchor(\"a\",(3,3),0,(0,3),\"red\"),Anchor(\"b\",(14,14),0,(0,3),\"blue\"),Anchor(\"c\",(18,12),0,(0,3),\"red\")]\n    m = Map((20,20))\n    m.placeAnchor(anchorList2d)\n    m.loadTraj([(0,0),(8,8),(6,6),(4,5),(10,4)],6)\n    m.visualize2D()\n    postPlot(m.points,m.gradNorms)\n</code></pre>"},{"location":"main/#localization_simulator.core.main.sampleRoutine3d","title":"<code>sampleRoutine3d()</code>","text":"<p>A sample routine for a 3D simulation</p> Source code in <code>localization_simulator/core/main.py</code> <pre><code>def sampleRoutine3d():\n\"\"\"A sample routine for a 3D simulation\n    \"\"\"\n    anchorList3d = [Anchor(\"a\",(3,3,3),0,(0,3),\"red\"),Anchor(\"b\",(14,14,14),0,(0,3),\"blue\"),Anchor(\"c\",(18,12,13),0,(0,3),\"red\")]\n    m = Map((20,20,20))\n    m.placeAnchor(anchorList3d)\n    m.loadTraj([(0,0,0),(8,8,8),(6,6,7),(4,5,4),(10,4,2)],12)\n    m.visualize3D()\n</code></pre>"},{"location":"map/","title":"map","text":"<p>A module for the map and assembling components for a simulation.</p> Todo <ul> <li>Decouple other entities from maps and make it simpler</li> <li>Allow for multiple trajectories</li> </ul>"},{"location":"map/#localization_simulator.core.map.Map","title":"<code>Map</code>","text":"<p>Module for creating simulation maps.</p> <p>Attributes:</p> Name Type Description <code>dim</code> <code>tuple[int]</code> <p>The dimensions of the map.</p> <code>nDim</code> <code>int</code> <p>The dimensionality of the map (2 or 3).</p> <code>fig</code> <code>Figure</code> <p>Matplotlib figure for visualization.</p> <code>ax</code> <code>Axes</code> <p>Matplotlib axes for visualization.</p> <code>trajectory</code> <code>Traj2D or Traj3D</code> <p>The trajectory for the simulation (either 2D or 3D).</p> <code>points</code> <code>list[list[ndarray(float)]]</code> <p>The list of points for each pose.</p> <code>gradNorms</code> <code>list[list[float]]</code> <p>The list of gradient norms for each pose.</p> Source code in <code>localization_simulator/core/map.py</code> <pre><code>class Map:\n\"\"\"Module for creating simulation maps.\n\n    Attributes:\n        dim (tuple[int]): The dimensions of the map.\n        nDim (int): The dimensionality of the map (2 or 3).\n        fig (matplotlib.figure.Figure): Matplotlib figure for visualization.\n        ax (matplotlib.axes._axes.Axes): Matplotlib axes for visualization.\n        trajectory (Traj2D or Traj3D): The trajectory for the simulation (either 2D or 3D).\n        points (list[list[Numpy.ndarray(float)]]): The list of points for each pose.\n        gradNorms (list[list[float]]): The list of gradient norms for each pose.\n    \"\"\"\n    def __init__(self, dim) -&gt; None:\n\"\"\"Init method\n\n        Args:\n            dim (tuple[int]): The dimension of the map to be created.\n        \"\"\"\n        self.dim = dim\n        self.nDim = len(dim)\n        self.fig, self.ax = Plot.create2D(self.dim) if self.nDim==2 else Plot.create3D(self.dim)\n        self.trajectory = None\n        self.points = []\n        self.gradNorms = []\n\n    def placeAnchor(self, anchorList):\n\"\"\"Method for placing anchors in a map.\n\n        Args:\n            anchorList (list[Anchor]): The list of anchors to place in a map.\n        \"\"\"\n        self.anchors = anchorList\n        if self.nDim == 2:\n            for a in anchorList:\n                self.ax.add_patch(Rectangle(a.location,0.5,0.5,fc=\"black\",ec=a.clr))\n        else:\n            for a in anchorList:\n                self.ax.scatter(a.location[0], a.location[1], a.location[2], c='black', edgecolors=a.clr ,marker='o', s=100)\n\n\n    def loadTraj(self, poses, interval):\n\"\"\"Method for loading a trajectory into a map\n\n        Args:\n            poses (list[tuple[float]]): The desired poses for the trajectory.\n            interval (int): The number of substeps in between each pose. Can be thought as the number of points in a straight line between poses.\n        \"\"\"\n        if self.nDim == 2:\n            self.trajectory = Traj2D(poses, interval)\n        else:\n            self.trajectory = Traj3D(poses, interval)\n        self.trajectory.generateTraj()\n\n    def createWindow(self):\n\"\"\"Creates a window to display pose tracking information using Tkinter.\n\n        The window currently displays the pose number as well as the distance and likelihood of observing the distance in the probability density for each anchor.\n\n        Returns:\n            (tuple[tk.Tk, tk.Label, ttk.Treeview]): The main tkinter window, the title widgetm and the treeview widget.\n        \"\"\"\n        root = tk.Tk()\n        root.title('Pose Tracker')\n\n        value_label = tk.Label(root, text=\"Pose Tracker\", font=(\"Arial\",30)).grid(row=0, columnspan=4)\n\n        cols = ('Pose', 'Anchor', 'Distance', 'Probability Density')\n        listBox = ttk.Treeview(root, columns=cols, show='headings')\n        for col in cols:\n            listBox.heading(col, text=col)    \n        listBox.grid(row=1, column=0, columnspan=2)\n\n        return root, value_label, listBox\n\n    def visualize2D(self):\n\"\"\"Visualizes the trajectory (2D) using Matplotlib animation\n        \"\"\"\n        nls = NLS(self.points,self.gradNorms, np.array([a.location for a in self.anchors]),variance=0.01, tolerance=0.1)\n\n        def show(listBox, send, num):\n\"\"\"Populate the treeview widget with values at each timestep\n\n            Args:\n                listBox (ttk.Treeview): The Treeview widget.\n                send (list): Values to be displayed in the Treeview widget.\n                num (int): The timestep\n            \"\"\"\n            for i in send:\n                listBox.insert(\"\", \"end\", values=(num,i[0], i[1], i[2]))\n\n        def update(num):\n\"\"\"Updates the line depicting the trajectory after each animation frame.\n\n            Args:\n                num (int): the frame number representing the timestep to be visualized.\n\n            Returns:\n                tuple[matplotlib.lines.Line2D,matplotlib.text.Text]: the updated line and title.\n            \"\"\"\n            data = self.trajectory.df.iloc[num:num+1]\n            ln.set_data(data.x, data.y)\n            if num % self.trajectory.interval == 0:\n                ln.set_color(np.random.rand(3,))\n            title.set_text('2D Test, pose={}'.format(num))\n\n            guess = np.array([np.random.uniform(0, self.dim[0]), np.random.uniform(0, self.dim[1])])\n            nls.process(np.array([data.x.item(),data.y.item()]), guess)\n\n            send = []\n            for a in self.anchors:\n                dist = a.getDist(self.trajectory.df.iloc[num])\n                send.append([a.name,dist,a.error.getPDF(dist)])\n\n            show(listBox, send, num)\n            return ln,title,\n\n        title = self.ax.text(0.5,0.90, \"\", bbox={'facecolor':'w', 'alpha':0.5, 'pad':5},\n                transform=self.ax.transAxes, ha=\"center\")\n\n        ln, = self.ax.plot(self.trajectory.df.x, self.trajectory.df.y, 'ro')\n\n        value_root, value_label, listBox = self.createWindow()\n\n        ani = FuncAnimation(self.fig, update, frames=self.trajectory.interval*(len(self.trajectory.poses)-1),\n                            blit=True, interval=500//self.trajectory.interval*(len(self.trajectory.poses)-1), repeat=False)\n\n        plt.show()\n        value_root.mainloop()\n\n    def visualize3D(self):\n\"\"\"Visualizes the trajectory (3D) using Matplotlib animation\n        \"\"\"\n\n        def show(listBox, send, num):\n\"\"\"Populate the treeview widget with values at each timestep\n\n            Args:\n                listBox (ttk.Treeview): The Treeview widget.\n                send (list): Values to be displayed in the Treeview widget.\n                num (int): The timestep\n            \"\"\"\n            for i in send:\n                listBox.insert(\"\", \"end\", values=(num, i[0], i[1], i[2]))\n\n        def update(num):\n\"\"\"Updates the trajectory graph after each animation frame.\n\n            Args:\n                num (int): the frame number to be visualized.\n\n            Returns:\n               (tuple[mpl_toolkits.mplot3d.art3d.Line3D,matplotlib.text.Text]) : the updated graph and title.\n            \"\"\"\n            data=self.trajectory.df.iloc[num:num+1]\n            graph.set_data (data.x, data.y)\n            graph.set_3d_properties(data.z)\n            if num % self.trajectory.interval == 0:\n                graph.set_color(np.random.rand(3,))\n            title.set_text('3D Test, pose={}'.format(num))\n\n            send = []\n            for a in self.anchors:\n                dist = a.getDist(self.trajectory.df.iloc[num])\n                send.append([a.name,dist,a.error.getPDF(dist)])\n\n            show(listBox, send, num)\n\n            return graph, title,\n\n        title = self.ax.text2D(0.05,0.95, \"\", bbox={'facecolor':'w', 'alpha':0.5, 'pad':5},\n                transform=self.ax.transAxes)\n\n        graph, = self.ax.plot(self.trajectory.df.x, self.trajectory.df.y, self.trajectory.df.z, linestyle=\"\", marker=\"o\")\n\n        value_root, value_label, listBox = self.createWindow()\n\n        ani = FuncAnimation(self.fig, update, self.trajectory.interval*(len(self.trajectory.poses)-1), interval=500//self.trajectory.interval*(len(self.trajectory.poses)-1), blit=True, repeat=False)\n\n        plt.show()\n        value_root.mainloop()\n</code></pre>"},{"location":"map/#localization_simulator.core.map.Map.__init__","title":"<code>__init__(dim)</code>","text":"<p>Init method</p> <p>Parameters:</p> Name Type Description Default <code>dim</code> <code>tuple[int]</code> <p>The dimension of the map to be created.</p> required Source code in <code>localization_simulator/core/map.py</code> <pre><code>def __init__(self, dim) -&gt; None:\n\"\"\"Init method\n\n    Args:\n        dim (tuple[int]): The dimension of the map to be created.\n    \"\"\"\n    self.dim = dim\n    self.nDim = len(dim)\n    self.fig, self.ax = Plot.create2D(self.dim) if self.nDim==2 else Plot.create3D(self.dim)\n    self.trajectory = None\n    self.points = []\n    self.gradNorms = []\n</code></pre>"},{"location":"map/#localization_simulator.core.map.Map.createWindow","title":"<code>createWindow()</code>","text":"<p>Creates a window to display pose tracking information using Tkinter.</p> <p>The window currently displays the pose number as well as the distance and likelihood of observing the distance in the probability density for each anchor.</p> <p>Returns:</p> Type Description <code>tuple[Tk, Label, Treeview]</code> <p>The main tkinter window, the title widgetm and the treeview widget.</p> Source code in <code>localization_simulator/core/map.py</code> <pre><code>def createWindow(self):\n\"\"\"Creates a window to display pose tracking information using Tkinter.\n\n    The window currently displays the pose number as well as the distance and likelihood of observing the distance in the probability density for each anchor.\n\n    Returns:\n        (tuple[tk.Tk, tk.Label, ttk.Treeview]): The main tkinter window, the title widgetm and the treeview widget.\n    \"\"\"\n    root = tk.Tk()\n    root.title('Pose Tracker')\n\n    value_label = tk.Label(root, text=\"Pose Tracker\", font=(\"Arial\",30)).grid(row=0, columnspan=4)\n\n    cols = ('Pose', 'Anchor', 'Distance', 'Probability Density')\n    listBox = ttk.Treeview(root, columns=cols, show='headings')\n    for col in cols:\n        listBox.heading(col, text=col)    \n    listBox.grid(row=1, column=0, columnspan=2)\n\n    return root, value_label, listBox\n</code></pre>"},{"location":"map/#localization_simulator.core.map.Map.loadTraj","title":"<code>loadTraj(poses, interval)</code>","text":"<p>Method for loading a trajectory into a map</p> <p>Parameters:</p> Name Type Description Default <code>poses</code> <code>list[tuple[float]]</code> <p>The desired poses for the trajectory.</p> required <code>interval</code> <code>int</code> <p>The number of substeps in between each pose. Can be thought as the number of points in a straight line between poses.</p> required Source code in <code>localization_simulator/core/map.py</code> <pre><code>def loadTraj(self, poses, interval):\n\"\"\"Method for loading a trajectory into a map\n\n    Args:\n        poses (list[tuple[float]]): The desired poses for the trajectory.\n        interval (int): The number of substeps in between each pose. Can be thought as the number of points in a straight line between poses.\n    \"\"\"\n    if self.nDim == 2:\n        self.trajectory = Traj2D(poses, interval)\n    else:\n        self.trajectory = Traj3D(poses, interval)\n    self.trajectory.generateTraj()\n</code></pre>"},{"location":"map/#localization_simulator.core.map.Map.placeAnchor","title":"<code>placeAnchor(anchorList)</code>","text":"<p>Method for placing anchors in a map.</p> <p>Parameters:</p> Name Type Description Default <code>anchorList</code> <code>list[Anchor]</code> <p>The list of anchors to place in a map.</p> required Source code in <code>localization_simulator/core/map.py</code> <pre><code>def placeAnchor(self, anchorList):\n\"\"\"Method for placing anchors in a map.\n\n    Args:\n        anchorList (list[Anchor]): The list of anchors to place in a map.\n    \"\"\"\n    self.anchors = anchorList\n    if self.nDim == 2:\n        for a in anchorList:\n            self.ax.add_patch(Rectangle(a.location,0.5,0.5,fc=\"black\",ec=a.clr))\n    else:\n        for a in anchorList:\n            self.ax.scatter(a.location[0], a.location[1], a.location[2], c='black', edgecolors=a.clr ,marker='o', s=100)\n</code></pre>"},{"location":"map/#localization_simulator.core.map.Map.visualize2D","title":"<code>visualize2D()</code>","text":"<p>Visualizes the trajectory (2D) using Matplotlib animation</p> Source code in <code>localization_simulator/core/map.py</code> <pre><code>def visualize2D(self):\n\"\"\"Visualizes the trajectory (2D) using Matplotlib animation\n    \"\"\"\n    nls = NLS(self.points,self.gradNorms, np.array([a.location for a in self.anchors]),variance=0.01, tolerance=0.1)\n\n    def show(listBox, send, num):\n\"\"\"Populate the treeview widget with values at each timestep\n\n        Args:\n            listBox (ttk.Treeview): The Treeview widget.\n            send (list): Values to be displayed in the Treeview widget.\n            num (int): The timestep\n        \"\"\"\n        for i in send:\n            listBox.insert(\"\", \"end\", values=(num,i[0], i[1], i[2]))\n\n    def update(num):\n\"\"\"Updates the line depicting the trajectory after each animation frame.\n\n        Args:\n            num (int): the frame number representing the timestep to be visualized.\n\n        Returns:\n            tuple[matplotlib.lines.Line2D,matplotlib.text.Text]: the updated line and title.\n        \"\"\"\n        data = self.trajectory.df.iloc[num:num+1]\n        ln.set_data(data.x, data.y)\n        if num % self.trajectory.interval == 0:\n            ln.set_color(np.random.rand(3,))\n        title.set_text('2D Test, pose={}'.format(num))\n\n        guess = np.array([np.random.uniform(0, self.dim[0]), np.random.uniform(0, self.dim[1])])\n        nls.process(np.array([data.x.item(),data.y.item()]), guess)\n\n        send = []\n        for a in self.anchors:\n            dist = a.getDist(self.trajectory.df.iloc[num])\n            send.append([a.name,dist,a.error.getPDF(dist)])\n\n        show(listBox, send, num)\n        return ln,title,\n\n    title = self.ax.text(0.5,0.90, \"\", bbox={'facecolor':'w', 'alpha':0.5, 'pad':5},\n            transform=self.ax.transAxes, ha=\"center\")\n\n    ln, = self.ax.plot(self.trajectory.df.x, self.trajectory.df.y, 'ro')\n\n    value_root, value_label, listBox = self.createWindow()\n\n    ani = FuncAnimation(self.fig, update, frames=self.trajectory.interval*(len(self.trajectory.poses)-1),\n                        blit=True, interval=500//self.trajectory.interval*(len(self.trajectory.poses)-1), repeat=False)\n\n    plt.show()\n    value_root.mainloop()\n</code></pre>"},{"location":"map/#localization_simulator.core.map.Map.visualize3D","title":"<code>visualize3D()</code>","text":"<p>Visualizes the trajectory (3D) using Matplotlib animation</p> Source code in <code>localization_simulator/core/map.py</code> <pre><code>def visualize3D(self):\n\"\"\"Visualizes the trajectory (3D) using Matplotlib animation\n    \"\"\"\n\n    def show(listBox, send, num):\n\"\"\"Populate the treeview widget with values at each timestep\n\n        Args:\n            listBox (ttk.Treeview): The Treeview widget.\n            send (list): Values to be displayed in the Treeview widget.\n            num (int): The timestep\n        \"\"\"\n        for i in send:\n            listBox.insert(\"\", \"end\", values=(num, i[0], i[1], i[2]))\n\n    def update(num):\n\"\"\"Updates the trajectory graph after each animation frame.\n\n        Args:\n            num (int): the frame number to be visualized.\n\n        Returns:\n           (tuple[mpl_toolkits.mplot3d.art3d.Line3D,matplotlib.text.Text]) : the updated graph and title.\n        \"\"\"\n        data=self.trajectory.df.iloc[num:num+1]\n        graph.set_data (data.x, data.y)\n        graph.set_3d_properties(data.z)\n        if num % self.trajectory.interval == 0:\n            graph.set_color(np.random.rand(3,))\n        title.set_text('3D Test, pose={}'.format(num))\n\n        send = []\n        for a in self.anchors:\n            dist = a.getDist(self.trajectory.df.iloc[num])\n            send.append([a.name,dist,a.error.getPDF(dist)])\n\n        show(listBox, send, num)\n\n        return graph, title,\n\n    title = self.ax.text2D(0.05,0.95, \"\", bbox={'facecolor':'w', 'alpha':0.5, 'pad':5},\n            transform=self.ax.transAxes)\n\n    graph, = self.ax.plot(self.trajectory.df.x, self.trajectory.df.y, self.trajectory.df.z, linestyle=\"\", marker=\"o\")\n\n    value_root, value_label, listBox = self.createWindow()\n\n    ani = FuncAnimation(self.fig, update, self.trajectory.interval*(len(self.trajectory.poses)-1), interval=500//self.trajectory.interval*(len(self.trajectory.poses)-1), blit=True, repeat=False)\n\n    plt.show()\n    value_root.mainloop()\n</code></pre>"},{"location":"nls/","title":"Newton Solver","text":"<p>A module for using Newtons method to approximate position at a given pose using the norm of the gradient.</p> Todo <ul> <li>Potentially look at adding a dampening factor in case of instability or excessive oscillation.</li> <li>Do more to decouple nls from maps.</li> </ul>"},{"location":"nls/#localization_simulator.utils.nls.NLS","title":"<code>NLS</code>","text":"<p>Newton solver for approximating the solution the solution at a given timestep.</p> <p>Attributes:</p> Name Type Description <code>points</code> <code>list[list[ndarray[float]]]</code> <p>All initial and subsequent approximations for each timestep.</p> <code>gradNorms</code> <code>list[list[float]]</code> <p>Gradient norms for the intial and subsequent approximations for each timestep.</p> <code>anchors</code> <code>list[tuple[float]]</code> <p>Locations of each anchor (either 2D or 3D).</p> <code>variance</code> <code>float</code> <p>The variance to be used for adding noise to measurements.</p> <code>tolerance</code> <code>float</code> <p>the maximum error before Newtons method stops iterating.</p> Source code in <code>localization_simulator/utils/nls.py</code> <pre><code>class NLS:\n\"\"\"Newton solver for approximating the solution the solution at a given timestep.\n\n    Attributes:\n        points (list[list[numpy.ndarray[float]]]): All initial and subsequent approximations for each timestep.\n        gradNorms (list[list[float]]): Gradient norms for the intial and subsequent approximations for each timestep.\n        anchors (list[tuple[float]]): Locations of each anchor (either 2D or 3D).\n        variance (float): The variance to be used for adding noise to measurements.\n        tolerance (float): the maximum error before Newtons method stops iterating.\n    \"\"\"\n    def __init__(self,points,gradNorms, anchors, variance, tolerance) -&gt; None:\n\"\"\"Init method\n\n        Args:\n            points (list[list[numpy.ndarray[float]]]): All initial and subsequent approximations for each timestep.\n            gradNorms (list[list[float]]): Gradient norms for the intial and subsequent approximations for each timestep.\n            anchors (list[tuple[float]]): Locations of each anchor (either 2D or 3D).\n            variance (float): The variance to be used for adding noise to measurements.\n            tolerance (float): the maximum error before Newtons method stops iterating.\n        \"\"\"\n        self.points = points\n        self.gradNorms = gradNorms\n        self.anchors = anchors\n        self.variance = variance\n        self.tolerance = tolerance\n\n    def addNoise(self, pose):\n\"\"\"Add noise to distance measurements.\n\n        Gaussian noise with a mean of 0 and a standard deviation determined by the specified variance is then added to\n        these distances to simulate measurement noise.\n\n        Args:\n            pose (numpy.ndarray[float]): The current pose of the robot\n\n        Returns:\n            (numpy.ndarray[float]): Noisy distance measurements from the robot to each anchor.\n        \"\"\"\n        x, y = pose\n        distances = np.sqrt((self.anchors[:, 0] - x)**2 + (self.anchors[:, 1] - y)**2)\n        noisy_distances = distances + np.random.normal(0, np.sqrt(self.variance), len(distances))\n        return noisy_distances\n\n    def eq(self, est_pose):\n\"\"\" \n        Calculates the Euclidean distances from anchor points to given pose.\n\n        Used as part of the objective function.\n\n        Args:\n            est_pose (numpy.ndarray[float]s): The pose estimate\n\n        Returns:\n            (numpy.ndarray[float]):  Euclidean distances from the estimated pose to each anchor\n        \"\"\"\n        est_x, est_y = est_pose\n        est_distances = np.sqrt((self.anchors[:, 0] - est_x)**2 + (self.anchors[:, 1] - est_y)**2)\n        return est_distances\n\n    # Using Newtons method and autograd for gradient and hessian\n    def estimatePose(self, est_pose, measurements):\n\"\"\"Estimate the pose using Newtons method. \n\n        Given an initial estimated pose and distance measurements, the method iteratively updates the estimated\n        pose using Newton's method. The error function is defined as the squared sum of differences between the estimated\n        distances and the actual measurements. Autograd is utilized to calculate the gradient and hessian of this error\n        function with respect to the estimated pose.\n\n        Args:\n            est_pose (numpy.ndarray[float]): The pose estimate\n            measurements (numpy.ndarray[float]): The noisy measurments from the pose to anchors\n\n        Returns:\n            (tuple[numpy.ndarray[float], float]): The updated estimated pose and the norm of the gradient.\n        \"\"\"\n        est_x, est_y = est_pose\n\n        g = grad(lambda p: np.sum((self.eq(p) - measurements)**2))(est_pose)\n        h = hessian(lambda p: np.sum((self.eq(p) - measurements)**2))(est_pose)\n\n        h_inv = np.linalg.pinv(h)\n        delta_pose = np.dot(h_inv, g)\n\n        est_x -= delta_pose[0]\n        est_y -= delta_pose[1]\n\n        return np.array([est_x, est_y]), np.linalg.norm(g)\n\n    def process(self, pose, guess):\n\"\"\"Perform Newtons method to refine an intial guess for the pose based on distance measurements until a tolerance is met.\n\n        Args:\n            pose (numpy.ndarray[float]): The actual pose\n            guess (numpy.ndarray[float]): The intial guess for a given poses. A randomly determined point on the map.\n        \"\"\"\n        p = []\n        grads = []\n        p.append(pose)\n        p.append(guess)\n        while True:\n            measurements = self.addNoise(pose)\n            guess, grad = self.estimatePose(guess, measurements)\n            p.append(guess)\n            grads.append(grad)\n            if grad &lt;= self.tolerance:\n                break\n        self.points.append(p)\n        self.gradNorms.append(grads)\n</code></pre>"},{"location":"nls/#localization_simulator.utils.nls.NLS.__init__","title":"<code>__init__(points, gradNorms, anchors, variance, tolerance)</code>","text":"<p>Init method</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[list[ndarray[float]]]</code> <p>All initial and subsequent approximations for each timestep.</p> required <code>gradNorms</code> <code>list[list[float]]</code> <p>Gradient norms for the intial and subsequent approximations for each timestep.</p> required <code>anchors</code> <code>list[tuple[float]]</code> <p>Locations of each anchor (either 2D or 3D).</p> required <code>variance</code> <code>float</code> <p>The variance to be used for adding noise to measurements.</p> required <code>tolerance</code> <code>float</code> <p>the maximum error before Newtons method stops iterating.</p> required Source code in <code>localization_simulator/utils/nls.py</code> <pre><code>def __init__(self,points,gradNorms, anchors, variance, tolerance) -&gt; None:\n\"\"\"Init method\n\n    Args:\n        points (list[list[numpy.ndarray[float]]]): All initial and subsequent approximations for each timestep.\n        gradNorms (list[list[float]]): Gradient norms for the intial and subsequent approximations for each timestep.\n        anchors (list[tuple[float]]): Locations of each anchor (either 2D or 3D).\n        variance (float): The variance to be used for adding noise to measurements.\n        tolerance (float): the maximum error before Newtons method stops iterating.\n    \"\"\"\n    self.points = points\n    self.gradNorms = gradNorms\n    self.anchors = anchors\n    self.variance = variance\n    self.tolerance = tolerance\n</code></pre>"},{"location":"nls/#localization_simulator.utils.nls.NLS.addNoise","title":"<code>addNoise(pose)</code>","text":"<p>Add noise to distance measurements.</p> <p>Gaussian noise with a mean of 0 and a standard deviation determined by the specified variance is then added to these distances to simulate measurement noise.</p> <p>Parameters:</p> Name Type Description Default <code>pose</code> <code>ndarray[float]</code> <p>The current pose of the robot</p> required <p>Returns:</p> Type Description <code>ndarray[float]</code> <p>Noisy distance measurements from the robot to each anchor.</p> Source code in <code>localization_simulator/utils/nls.py</code> <pre><code>def addNoise(self, pose):\n\"\"\"Add noise to distance measurements.\n\n    Gaussian noise with a mean of 0 and a standard deviation determined by the specified variance is then added to\n    these distances to simulate measurement noise.\n\n    Args:\n        pose (numpy.ndarray[float]): The current pose of the robot\n\n    Returns:\n        (numpy.ndarray[float]): Noisy distance measurements from the robot to each anchor.\n    \"\"\"\n    x, y = pose\n    distances = np.sqrt((self.anchors[:, 0] - x)**2 + (self.anchors[:, 1] - y)**2)\n    noisy_distances = distances + np.random.normal(0, np.sqrt(self.variance), len(distances))\n    return noisy_distances\n</code></pre>"},{"location":"nls/#localization_simulator.utils.nls.NLS.eq","title":"<code>eq(est_pose)</code>","text":"<p>Calculates the Euclidean distances from anchor points to given pose.</p> <p>Used as part of the objective function.</p> <p>Parameters:</p> Name Type Description Default <code>est_pose</code> <code>numpy.ndarray[float]s</code> <p>The pose estimate</p> required <p>Returns:</p> Type Description <code>ndarray[float]</code> <p>Euclidean distances from the estimated pose to each anchor</p> Source code in <code>localization_simulator/utils/nls.py</code> <pre><code>def eq(self, est_pose):\n\"\"\" \n    Calculates the Euclidean distances from anchor points to given pose.\n\n    Used as part of the objective function.\n\n    Args:\n        est_pose (numpy.ndarray[float]s): The pose estimate\n\n    Returns:\n        (numpy.ndarray[float]):  Euclidean distances from the estimated pose to each anchor\n    \"\"\"\n    est_x, est_y = est_pose\n    est_distances = np.sqrt((self.anchors[:, 0] - est_x)**2 + (self.anchors[:, 1] - est_y)**2)\n    return est_distances\n</code></pre>"},{"location":"nls/#localization_simulator.utils.nls.NLS.estimatePose","title":"<code>estimatePose(est_pose, measurements)</code>","text":"<p>Estimate the pose using Newtons method. </p> <p>Given an initial estimated pose and distance measurements, the method iteratively updates the estimated pose using Newton's method. The error function is defined as the squared sum of differences between the estimated distances and the actual measurements. Autograd is utilized to calculate the gradient and hessian of this error function with respect to the estimated pose.</p> <p>Parameters:</p> Name Type Description Default <code>est_pose</code> <code>ndarray[float]</code> <p>The pose estimate</p> required <code>measurements</code> <code>ndarray[float]</code> <p>The noisy measurments from the pose to anchors</p> required <p>Returns:</p> Type Description <code>tuple[ndarray[float], float]</code> <p>The updated estimated pose and the norm of the gradient.</p> Source code in <code>localization_simulator/utils/nls.py</code> <pre><code>def estimatePose(self, est_pose, measurements):\n\"\"\"Estimate the pose using Newtons method. \n\n    Given an initial estimated pose and distance measurements, the method iteratively updates the estimated\n    pose using Newton's method. The error function is defined as the squared sum of differences between the estimated\n    distances and the actual measurements. Autograd is utilized to calculate the gradient and hessian of this error\n    function with respect to the estimated pose.\n\n    Args:\n        est_pose (numpy.ndarray[float]): The pose estimate\n        measurements (numpy.ndarray[float]): The noisy measurments from the pose to anchors\n\n    Returns:\n        (tuple[numpy.ndarray[float], float]): The updated estimated pose and the norm of the gradient.\n    \"\"\"\n    est_x, est_y = est_pose\n\n    g = grad(lambda p: np.sum((self.eq(p) - measurements)**2))(est_pose)\n    h = hessian(lambda p: np.sum((self.eq(p) - measurements)**2))(est_pose)\n\n    h_inv = np.linalg.pinv(h)\n    delta_pose = np.dot(h_inv, g)\n\n    est_x -= delta_pose[0]\n    est_y -= delta_pose[1]\n\n    return np.array([est_x, est_y]), np.linalg.norm(g)\n</code></pre>"},{"location":"nls/#localization_simulator.utils.nls.NLS.process","title":"<code>process(pose, guess)</code>","text":"<p>Perform Newtons method to refine an intial guess for the pose based on distance measurements until a tolerance is met.</p> <p>Parameters:</p> Name Type Description Default <code>pose</code> <code>ndarray[float]</code> <p>The actual pose</p> required <code>guess</code> <code>ndarray[float]</code> <p>The intial guess for a given poses. A randomly determined point on the map.</p> required Source code in <code>localization_simulator/utils/nls.py</code> <pre><code>def process(self, pose, guess):\n\"\"\"Perform Newtons method to refine an intial guess for the pose based on distance measurements until a tolerance is met.\n\n    Args:\n        pose (numpy.ndarray[float]): The actual pose\n        guess (numpy.ndarray[float]): The intial guess for a given poses. A randomly determined point on the map.\n    \"\"\"\n    p = []\n    grads = []\n    p.append(pose)\n    p.append(guess)\n    while True:\n        measurements = self.addNoise(pose)\n        guess, grad = self.estimatePose(guess, measurements)\n        p.append(guess)\n        grads.append(grad)\n        if grad &lt;= self.tolerance:\n            break\n    self.points.append(p)\n    self.gradNorms.append(grads)\n</code></pre>"},{"location":"plot/","title":"plot","text":"<p>A module for creating the plots used for the simulations as well as post plotting of any analysis.</p> Todo <ul> <li>Add all other post plotting (results table comparing different algorithms first)</li> <li>Make the post plotting process smarter and way more efficient</li> <li>Improve overall visualizations</li> </ul>"},{"location":"plot/#localization_simulator.core.plot.Plot","title":"<code>Plot</code>","text":"<p>A module for creating plot environments that are used as the map in a simulation. Users have the option of creating 2D and 3D maps plots.</p> Source code in <code>localization_simulator/core/plot.py</code> <pre><code>class Plot:\n\"\"\"\n    A module for creating plot environments that are used as the map in a simulation.\n    Users have the option of creating 2D and 3D maps plots.\n    \"\"\"\n    @staticmethod\n    def create2D(dim):\n\"\"\"Static method to create a plot for a 2D map.\n        \"\"\"\n        fig = plt.figure()\n        ax = fig.add_subplot(111)\n        ax.set_xlim(0,dim[0])\n        ax.set_ylim(0,dim[1])\n        return fig, ax\n\n    @staticmethod\n    def create3D(dim):\n\"\"\"Static method to create a plot for a 3D map.\n        \"\"\"\n        fig = plt.figure()\n        ax = fig.add_subplot(111, projection='3d')\n        ax.axes.set_xlim3d(left=0, right=dim[0]) \n        ax.axes.set_ylim3d(bottom=0, top=dim[1]) \n        ax.axes.set_zlim3d(bottom=0, top=dim[2]) \n        return fig, ax\n</code></pre>"},{"location":"plot/#localization_simulator.core.plot.Plot.create2D","title":"<code>create2D(dim)</code>  <code>staticmethod</code>","text":"<p>Static method to create a plot for a 2D map.</p> Source code in <code>localization_simulator/core/plot.py</code> <pre><code>@staticmethod\ndef create2D(dim):\n\"\"\"Static method to create a plot for a 2D map.\n    \"\"\"\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    ax.set_xlim(0,dim[0])\n    ax.set_ylim(0,dim[1])\n    return fig, ax\n</code></pre>"},{"location":"plot/#localization_simulator.core.plot.Plot.create3D","title":"<code>create3D(dim)</code>  <code>staticmethod</code>","text":"<p>Static method to create a plot for a 3D map.</p> Source code in <code>localization_simulator/core/plot.py</code> <pre><code>@staticmethod\ndef create3D(dim):\n\"\"\"Static method to create a plot for a 3D map.\n    \"\"\"\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection='3d')\n    ax.axes.set_xlim3d(left=0, right=dim[0]) \n    ax.axes.set_ylim3d(bottom=0, top=dim[1]) \n    ax.axes.set_zlim3d(bottom=0, top=dim[2]) \n    return fig, ax\n</code></pre>"},{"location":"plot/#localization_simulator.core.plot.postPlot","title":"<code>postPlot(points, gradNorms)</code>","text":"<p>Post plotting for Newton's method performed at each pose. The first window contains an initial guess, followed by consecutive guesses until a conditional decision is met. The second window shows plots for the gradient norm and log of the gradient norm. (Space needs to be better managed)</p> <p>Parameters:</p> Name Type Description Default <code>points</code> <code>list[list[ndarray(float)]]</code> <p>The list of points for each pose.</p> required <code>gradNorms</code> <code>list[list[float]]</code> <p>The list of gradient norms for each pose.</p> required Source code in <code>localization_simulator/core/plot.py</code> <pre><code>def postPlot(points, gradNorms):\n\"\"\"\n    Post plotting for Newton's method performed at each pose.\n    The first window contains an initial guess, followed by consecutive guesses until a conditional decision is met.\n    The second window shows plots for the gradient norm and log of the gradient norm.\n    (Space needs to be better managed)\n\n    Args:\n        points (list[list[Numpy.ndarray(float)]]): The list of points for each pose.\n        gradNorms (list[list[float]]): The list of gradient norms for each pose.\n    \"\"\"\n    for i, (p, gn) in enumerate(zip(points, gradNorms), start=1):\n        x, y = zip(*p) \n\n        plt.scatter(x[1], y[1], color='green', marker='o', label=\"Initial\")\n        plt.scatter(x[-1], y[-1], color='blue', marker='x', label=\"Final\")\n        plt.scatter(x[2:-1], y[2:-1], color='red', marker='x')\n        for i, (xi, yi) in enumerate(zip(x[2:-1], y[2:-1]), start=1):\n           plt.text(xi, yi, str(i), ha='right', va='bottom')\n        plt.title(f\"Approx for {x[0]},{y[0]}\")\n        plt.legend()\n        # plt.show()\n        plt.show(block=False)\n        plt.pause(2)\n        plt.close()\n\n        fig, axs = plt.subplots(2)\n        fig.suptitle(f\"Approx for {x[0]},{y[0]}\")\n        axs[0].plot(range(1, len(gn) + 1), gn, color='purple', marker='o', label='Grad Norms')\n        log_gn = np.log(gn)\n        axs[1].plot(range(1, len(log_gn) + 1), log_gn, color='orange', marker='o', label='Log Grad Norms')\n\n        plt.show(block=False)\n        # input(\"Press a key \")\n        plt.pause(2)\n        plt.close()\n</code></pre>"},{"location":"trajectory/","title":"trajectory","text":"<p>A module for creating robot trajectories in 2D or 3D environments.</p> Todo <ul> <li>Improve trajectory mechanics by introducing curvature (cubic/quintic spline, bezier curves)</li> <li>Add more timestep options</li> </ul>"},{"location":"trajectory/#localization_simulator.utils.trajectory.Traj2D","title":"<code>Traj2D</code>","text":"<p>A class to create 2D trajectories.</p> <p>Attributes:</p> Name Type Description <code>poses</code> <code>list[tuple[float]]</code> <p>The desired poses for the trajectory.</p> <code>interval</code> <code>int</code> <p>The number of substeps in between each pose. Can be thought as the number of points in a straight line between poses.</p> <code>data</code> <code>dict{str</code> <p>list[float]}): A dictionary with the complete trajectory split off into x and y components.</p> <code>df</code> <code>DataFrame</code> <p>A dataframe of the trajectory data</p> Source code in <code>localization_simulator/utils/trajectory.py</code> <pre><code>class Traj2D:\n\"\"\"A class to create 2D trajectories.\n\n    Attributes:\n        poses (list[tuple[float]]): The desired poses for the trajectory.\n        interval (int): The number of substeps in between each pose. Can be thought as the number of points in a straight line between poses.\n        data (dict{str:list[float]}): A dictionary with the complete trajectory split off into x and y components.\n        df (pandas.DataFrame): A dataframe of the trajectory data\n    \"\"\"\n    def __init__(self, poses, interval) -&gt; None:\n\"\"\"Init method\n\n        Args:\n            poses (list[tuple[float]]): The desired poses for the trajectory.\n            interval (int): The number of substeps in between each pose. Can be thought as the number of points in a straight line between poses.\n        \"\"\"\n        self.poses = poses\n        self.interval = interval\n        self.data = {\n            \"x\":[],\n            \"y\":[]\n        }\n        self.df = None\n\n    def generateTraj(self):\n\"\"\"Generates the trajectory based on the given poses and interval steps to added between them\n        \"\"\"\n        for cur in range(len(self.poses)-1):\n            self.data[\"x\"].extend(np.linspace(self.poses[cur][0], self.poses[cur+1][0], self.interval))\n            self.data[\"y\"].extend(np.linspace(self.poses[cur][1], self.poses[cur+1][1], self.interval))\n        self.df = pd.DataFrame(self.data)\n\n    def visualizeTraj(self):\n\"\"\"Visualizes the trajectory using Matplotlib animation\n        \"\"\"\n\n        def init():\n\"\"\"Init method for the visualization plot that sets the x and y limits based on the poses.\n\n            Returns:\n                matplotlib.lines.Line2D: the trajectory line\n            \"\"\"\n            ax.set_xlim(0, max([i[0] for i in self.poses]))\n            ax.set_ylim(0, max([i[1] for i in self.poses]))\n            return ln,\n\n        def update(num):\n\"\"\"Updates the line depicting the trajectory after each animation frame.\n\n            Args:\n                num (int): the frame number representing the timestep to be visualized.\n\n            Returns:\n                tuple[matplotlib.lines.Line2D,matplotlib.text.Text]: the updated line and title.\n            \"\"\"\n            data = self.df.iloc[num:num+1]\n            ln.set_data(data.x, data.y)\n            if num % self.interval == 0:\n                ln.set_color(np.random.rand(3,))\n            title.set_text('2D Test, pose={}'.format(num))\n            return ln,title,\n\n        fig = plt.figure()\n        ax = fig.add_subplot(111)\n        title = ax.text(0.5,0.90, \"\", bbox={'facecolor':'w', 'alpha':0.5, 'pad':5},\n                transform=ax.transAxes, ha=\"center\")\n\n        ln, = ax.plot(self.df.x, self.df.y, 'ro')\n\n        ani = FuncAnimation(fig, update, frames=self.interval*(len(self.poses)-1),\n                            init_func=init, blit=True, interval=500//self.interval*(len(self.poses)-1), repeat=False)\n        plt.show()\n</code></pre>"},{"location":"trajectory/#localization_simulator.utils.trajectory.Traj2D.__init__","title":"<code>__init__(poses, interval)</code>","text":"<p>Init method</p> <p>Parameters:</p> Name Type Description Default <code>poses</code> <code>list[tuple[float]]</code> <p>The desired poses for the trajectory.</p> required <code>interval</code> <code>int</code> <p>The number of substeps in between each pose. Can be thought as the number of points in a straight line between poses.</p> required Source code in <code>localization_simulator/utils/trajectory.py</code> <pre><code>def __init__(self, poses, interval) -&gt; None:\n\"\"\"Init method\n\n    Args:\n        poses (list[tuple[float]]): The desired poses for the trajectory.\n        interval (int): The number of substeps in between each pose. Can be thought as the number of points in a straight line between poses.\n    \"\"\"\n    self.poses = poses\n    self.interval = interval\n    self.data = {\n        \"x\":[],\n        \"y\":[]\n    }\n    self.df = None\n</code></pre>"},{"location":"trajectory/#localization_simulator.utils.trajectory.Traj2D.generateTraj","title":"<code>generateTraj()</code>","text":"<p>Generates the trajectory based on the given poses and interval steps to added between them</p> Source code in <code>localization_simulator/utils/trajectory.py</code> <pre><code>def generateTraj(self):\n\"\"\"Generates the trajectory based on the given poses and interval steps to added between them\n    \"\"\"\n    for cur in range(len(self.poses)-1):\n        self.data[\"x\"].extend(np.linspace(self.poses[cur][0], self.poses[cur+1][0], self.interval))\n        self.data[\"y\"].extend(np.linspace(self.poses[cur][1], self.poses[cur+1][1], self.interval))\n    self.df = pd.DataFrame(self.data)\n</code></pre>"},{"location":"trajectory/#localization_simulator.utils.trajectory.Traj2D.visualizeTraj","title":"<code>visualizeTraj()</code>","text":"<p>Visualizes the trajectory using Matplotlib animation</p> Source code in <code>localization_simulator/utils/trajectory.py</code> <pre><code>def visualizeTraj(self):\n\"\"\"Visualizes the trajectory using Matplotlib animation\n    \"\"\"\n\n    def init():\n\"\"\"Init method for the visualization plot that sets the x and y limits based on the poses.\n\n        Returns:\n            matplotlib.lines.Line2D: the trajectory line\n        \"\"\"\n        ax.set_xlim(0, max([i[0] for i in self.poses]))\n        ax.set_ylim(0, max([i[1] for i in self.poses]))\n        return ln,\n\n    def update(num):\n\"\"\"Updates the line depicting the trajectory after each animation frame.\n\n        Args:\n            num (int): the frame number representing the timestep to be visualized.\n\n        Returns:\n            tuple[matplotlib.lines.Line2D,matplotlib.text.Text]: the updated line and title.\n        \"\"\"\n        data = self.df.iloc[num:num+1]\n        ln.set_data(data.x, data.y)\n        if num % self.interval == 0:\n            ln.set_color(np.random.rand(3,))\n        title.set_text('2D Test, pose={}'.format(num))\n        return ln,title,\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111)\n    title = ax.text(0.5,0.90, \"\", bbox={'facecolor':'w', 'alpha':0.5, 'pad':5},\n            transform=ax.transAxes, ha=\"center\")\n\n    ln, = ax.plot(self.df.x, self.df.y, 'ro')\n\n    ani = FuncAnimation(fig, update, frames=self.interval*(len(self.poses)-1),\n                        init_func=init, blit=True, interval=500//self.interval*(len(self.poses)-1), repeat=False)\n    plt.show()\n</code></pre>"},{"location":"trajectory/#localization_simulator.utils.trajectory.Traj3D","title":"<code>Traj3D</code>","text":"<p>             Bases: <code>Traj2D</code></p> <p>A class to create 3D trajectories.</p> <p>Attributes:</p> Name Type Description <code>poses</code> <code>list[tuple[int]]</code> <p>The desired poses for the trajectory.</p> <code>interval</code> <code>int</code> <p>The number of substeps in between each pose. Can be thought as the number of points in a straight line between poses.</p> <code>data</code> <code>dict{str</code> <p>list[int]}): A dictionary with the complete trajectory split off into x,y,and z components.</p> <code>df</code> <code>DataFrame</code> <p>A dataframe of the trajectory data</p> Source code in <code>localization_simulator/utils/trajectory.py</code> <pre><code>class Traj3D(Traj2D):\n\"\"\"A class to create 3D trajectories.\n\n    Attributes:\n        poses (list[tuple[int]]): The desired poses for the trajectory.\n        interval (int): The number of substeps in between each pose. Can be thought as the number of points in a straight line between poses.\n        data (dict{str:list[int]}): A dictionary with the complete trajectory split off into x,y,and z components.\n        df (pandas.DataFrame): A dataframe of the trajectory data\n    \"\"\"\n\n    def __init__(self, poses, interval) -&gt; None:\n\"\"\"Init method\n\n        Args:\n            poses (list[tuple[int]]): The desired poses for the trajectory.\n            interval (int): The number of substeps in between each pose. Can be thought as the number of points in a straight line between poses.\n        \"\"\"\n        super().__init__(poses, interval)\n        self.data = {\n            \"x\":[],\n            \"y\":[],\n            \"z\":[]\n        }\n        self.df = None\n\n    def generateTraj(self):\n\"\"\"Generates the trajectory based on the given poses and interval steps to added between them\n        \"\"\"\n        for cur in range(len(self.poses)-1):\n            self.data[\"x\"].extend(np.linspace(self.poses[cur][0], self.poses[cur+1][0], self.interval))\n            self.data[\"y\"].extend(np.linspace(self.poses[cur][1], self.poses[cur+1][1], self.interval))\n            self.data[\"z\"].extend(np.linspace(self.poses[cur][2], self.poses[cur+1][2], self.interval))\n        self.df = pd.DataFrame(self.data)\n\n    def visualizeTraj(self):\n\"\"\"Visualizes the trajectory using Matplotlib animation\n        \"\"\"\n\n        def update_graph(num):\n\"\"\"Updates the trajectory graph after each animation frame.\n\n            Args:\n                num (int): the frame number to be visualized.\n\n            Returns:\n               (tuple[mpl_toolkits.mplot3d.art3d.Line3D,matplotlib.text.Text]) : the updated graph and title.\n            \"\"\"\n            data=self.df.iloc[num:num+1]\n            graph.set_data (data.x, data.y)\n            graph.set_3d_properties(data.z)\n            print(type(graph))\n            print(type(title))\n\n            if num % self.interval == 0:\n                graph.set_color(np.random.rand(3,))\n            title.set_text(f'3D Test, pose={num}')\n            return graph, title,\n\n\n        fig = plt.figure()\n        ax = fig.add_subplot(111, projection='3d')\n        title = ax.text2D(0.05,0.95, \"\", bbox={'facecolor':'w', 'alpha':0.5, 'pad':5},\n                transform=ax.transAxes)\n\n\n        graph, = ax.plot(self.df.x, self.df.y, self.df.z, linestyle=\"\", marker=\"o\")\n\n        ani = FuncAnimation(fig, update_graph, self.interval*(len(self.poses)-1), interval=500//self.interval*(len(self.poses)-1), blit=True, repeat=False)\n\n        plt.show()\n</code></pre>"},{"location":"trajectory/#localization_simulator.utils.trajectory.Traj3D.__init__","title":"<code>__init__(poses, interval)</code>","text":"<p>Init method</p> <p>Parameters:</p> Name Type Description Default <code>poses</code> <code>list[tuple[int]]</code> <p>The desired poses for the trajectory.</p> required <code>interval</code> <code>int</code> <p>The number of substeps in between each pose. Can be thought as the number of points in a straight line between poses.</p> required Source code in <code>localization_simulator/utils/trajectory.py</code> <pre><code>def __init__(self, poses, interval) -&gt; None:\n\"\"\"Init method\n\n    Args:\n        poses (list[tuple[int]]): The desired poses for the trajectory.\n        interval (int): The number of substeps in between each pose. Can be thought as the number of points in a straight line between poses.\n    \"\"\"\n    super().__init__(poses, interval)\n    self.data = {\n        \"x\":[],\n        \"y\":[],\n        \"z\":[]\n    }\n    self.df = None\n</code></pre>"},{"location":"trajectory/#localization_simulator.utils.trajectory.Traj3D.generateTraj","title":"<code>generateTraj()</code>","text":"<p>Generates the trajectory based on the given poses and interval steps to added between them</p> Source code in <code>localization_simulator/utils/trajectory.py</code> <pre><code>def generateTraj(self):\n\"\"\"Generates the trajectory based on the given poses and interval steps to added between them\n    \"\"\"\n    for cur in range(len(self.poses)-1):\n        self.data[\"x\"].extend(np.linspace(self.poses[cur][0], self.poses[cur+1][0], self.interval))\n        self.data[\"y\"].extend(np.linspace(self.poses[cur][1], self.poses[cur+1][1], self.interval))\n        self.data[\"z\"].extend(np.linspace(self.poses[cur][2], self.poses[cur+1][2], self.interval))\n    self.df = pd.DataFrame(self.data)\n</code></pre>"},{"location":"trajectory/#localization_simulator.utils.trajectory.Traj3D.visualizeTraj","title":"<code>visualizeTraj()</code>","text":"<p>Visualizes the trajectory using Matplotlib animation</p> Source code in <code>localization_simulator/utils/trajectory.py</code> <pre><code>def visualizeTraj(self):\n\"\"\"Visualizes the trajectory using Matplotlib animation\n    \"\"\"\n\n    def update_graph(num):\n\"\"\"Updates the trajectory graph after each animation frame.\n\n        Args:\n            num (int): the frame number to be visualized.\n\n        Returns:\n           (tuple[mpl_toolkits.mplot3d.art3d.Line3D,matplotlib.text.Text]) : the updated graph and title.\n        \"\"\"\n        data=self.df.iloc[num:num+1]\n        graph.set_data (data.x, data.y)\n        graph.set_3d_properties(data.z)\n        print(type(graph))\n        print(type(title))\n\n        if num % self.interval == 0:\n            graph.set_color(np.random.rand(3,))\n        title.set_text(f'3D Test, pose={num}')\n        return graph, title,\n\n\n    fig = plt.figure()\n    ax = fig.add_subplot(111, projection='3d')\n    title = ax.text2D(0.05,0.95, \"\", bbox={'facecolor':'w', 'alpha':0.5, 'pad':5},\n            transform=ax.transAxes)\n\n\n    graph, = ax.plot(self.df.x, self.df.y, self.df.z, linestyle=\"\", marker=\"o\")\n\n    ani = FuncAnimation(fig, update_graph, self.interval*(len(self.poses)-1), interval=500//self.interval*(len(self.poses)-1), blit=True, repeat=False)\n\n    plt.show()\n</code></pre>"}]}